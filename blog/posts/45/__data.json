{"type":"data","nodes":[null,{"type":"data","data":[{"blog":1,"blogId":9,"blogContent":10},{"id":2,"title":3,"description":4,"createdAt":5,"approxTimeToRead":6,"coverImageUrl":7,"__typename":8},45,"Referential Data Validations with yupjs","How do I validate properties on an object where references to other properties is required?","2021-05-23T13:42:40.000Z","PT5M","/store/48-my-personal-computing-setup/img.cover.jpeg","Blog","45","## What is Data Validation?\n\nData validation is the process of checking whether a given value fits certain criteria based on its business requirements.\n\nFor any input - a UI input field or an API input body, data validation is crucial. Any arbitrary input should never be trusted. And data validation plays a vital role in making sure these inputs are rigorously funnelled through the right pipes before they create unintended side-effects in our applications.\n\n## Data Validation in the JavaScript world\n\nIn JavaScript projects, both the browser and node.js, that is, there are several npm packages available to do data validation. I've personally used joi and yupjs.\n\njoi was my goto choice for Data Validation for a long time. It worked really well with hapijs and has a great community around it. Trust me, I don't have anything against joi, it's just that I find yupjs to be more easier for me to work with.\n\nyupjs is also a data validation library, and gets lots of its characteristics from joi but focuses more on client side validation and can be easily extended.\n\n## An example of a Data Validation\n\nData validations are done on each property of an incoming \"Data Transfer Object\". Just a fancy way ðŸŽ“ of saying an object which is created from the raw inputs and passed along for cleaning and processing before actually getting stored or used in other places of an application.\n\nLet's take a simple signup page example. We will have two inputs and the DTO will have the shape shown below: \n\n```tsx\ntype SignUpDto = {\n  userName: string | undefined,\n  password: string | undefined\n}\n```\n\nSimple data validations here are:\n\n- the userName and password fields are required\n- userName should be of a maximum length of 12\n- password should be a minimum length of 8\n\netc.\n\n## Enter yupjs\n\nTo achieve this, yupjs uses a concept called as a schema for validation. I'm sure you'll find the yupjs library very similar to joi, so let's take a look. The simple validations for the userName and password can be written like shown below:\n\n```tsx\nimport * as yup from 'yup'\n\ntype SignUpDto = {\n  userName: string | undefined,\n  password: string | undefined\n}\n\nconst signUpSchema = yup.object({\n  userName: yup\n    .string()\n    .required('please enter a username')\n    .max(12),\n  password: yup\n    .string()\n    .required('please enter a password')\n    .min(8)\n})\n```\n\nAs you can see, you can define custom error message for each validation as well. Now this `signUpSchema` can be used to actually to the data validation, which is shown below:\n\n```tsx\nconst signUp: SignUpDto = {\n  userName: 'sample',\n  password: undefined\n}\n\nsignUpSchema.validate(signUp, { abortEarly: false })\n  .then(console.log)\n  .catch(console.error)\n\n>\nValidationError: please enter a password\n    at finishTestRun (.../node_modules/yup/lib/util/runTests.js:63:20)\n    at .../node_modules/yup/lib/util/runTests.js:17:5\n    at finishTestRun (.../node_modules/yup/lib/util/runTests.js:67:9)\n    at .../node_modules/yup/lib/util/createValidation.js:72:127 {\n  value: { userName: 'sample', password: undefined },\n  path: undefined,\n  type: undefined,\n  errors: [ 'please enter a password' ],\n  inner: [\n    ValidationError: please enter a password\n        at createError (/Users/sauravsahu/Documents/personal/code/yuppers/node_modules/yup/lib/util/createValidation.js:54:21)\n        at /Users/sauravsahu/Documents/personal/code/yuppers/node_modules/yup/lib/util/createValidation.js:72:107 {\n      value: undefined,\n      path: 'password',\n      type: 'required',\n      errors: [Array],\n      inner: [],\n      params: [Object]\n    }\n  ]\n}\n```\n\nAs we can see, we get the detailed explanation as to why the validation failed in the `inner` property. I map over the `inner` property and keep only the path and value fields - this is enough for my frontend app to understand what localised message to show.\n\n```tsx\nsignUpSchema.validate(signUp, { abortEarly: false })\n  .then(console.log)\n  .catch(err => {\n    var validationErrors = err.inner.map((error: any) => ({ type: error.type, path: error.path }))\n    console.error(JSON.stringify(validationErrors, undefined, 2))\n  })\n\n>\n[\n  {\n    \"type\": \"required\",\n    \"path\": \"password\"\n  }\n]\n```\n\nThis is great, and yupjs has support for lots of different types of validations out-of-the-box, listed here - https://github.com/jquense/yup#api\n\n## What is referential validation?\n\nUnlike some validation rules which depend on just one key of a property, more complex validations could reference other properties as well. yupjs allows us to refer to other property of our DTO with `test` methods.\n\nFor our example, let's say we want to make sure the password doesn't contain the username as a string - meaning, if username is `sample`, password cannot be `123saMplE456` because the word sample appears in the sample. \n\nTo validate this password, we need to refer to the username field as well. We can write this with the `test` method from yupjs. Let's modify our schema as shown below.\n\n```tsx\nconst signUpSchema = yup.object({\n   userName: yup\n     .string()\n     .required('please enter a username')\n     .max(12),\n   password: yup\n     .string()\n     .required('please enter a password')\n     .min(8)\n+    .test('contains-username', (password, context) => {\n+      const { userName } = context.parent;\n+      const userNameString = userName ?? '';\n+      const containsUserName = (password ?? '').toLowerCase().includes(userNameString.toLowerCase())\n+\n+      return !containsUserName\n+    })\n })\n```\n\nAs you can see, I've added default values with the null coalescing operator as `userName` and `password` could be falsey.\n\nNow if we try to validate our sample user, we get this validation error, which is exactly what we wanted.\n\n```tsx\n[\n  {\n    \"type\": \"contains-username\",\n    \"path\": \"password\"\n\t}\n]\n```\n\nFor the `test` method, the first argument is the name of the validation, for us, it is `contains-username` and the second method is the actual test function which gets the current value and the context with which it is getting validated, and we can pick the `userName` with this context.\n\n## Conclusion\n\nyupjs is a very versatile data validation library. It can used in both the browser and in node.js. It has great in-built validators but also supports custom validation. Referential validation is a breeze and those methods can be easily unit-tested as well.\n\nyupjs also contains casting methods to transform objects from one shape to other. I'm currently enjoying yupjs on the [Daily Vocab App](https://github.com/daily-vocab/daily-vocab) \n\nHave a great one! Keep on coding.\n\n\\- [mrsauravsahu](https://poly.work/mrsauravsahu)"],"uses":{"params":["blogId"]}}]}
