{"type":"data","nodes":[null,{"type":"data","data":[{"blog":1,"blogId":9,"blogContent":10},{"id":2,"title":3,"description":4,"createdAt":5,"approxTimeToRead":6,"coverImageUrl":7,"__typename":8},46,"Downsizing Docker Images (~20X Improvement)","Let's see how to create smaller docker images for all your projects","2021-06-18T04:41:09.000Z","PT4M","/store/48-my-personal-computing-setup/img.cover.jpeg","Blog","46","Docker is great, isn't it? It has solved so many problems and helps developers easily deploy applications without complex configuration. But it's also our responsibility to use it well. Docker images are basically templates that will create containers will which run our application - so it is important that we package our application which creates the most optimized and compact results. This is to ensure that our docker images can be used more effectively - deploying your image as a microservice? It's best to have light-weight services. Writing these docker images to a container registry? Save space and store the most optimized docker images.\n\n> Note: Even though we're going to take a look at a sample nestjs application, this applies to any sort of application you're building.\n\nYou can find the entire repository here and you can experiment with this. So, to give you a brief about the app, it's a basic hello API which has one route that returns some information about itself. If you run the app locally, with a `PORT=8080 npm start` you can see the response by sending a request to `GET /`\n\nHere's a sample response:\n\n```json\n{\n    \"data\": {\n        \"app\": \"hello\",\n        \"version\": \"v0.0.1\"\n    }\n}\n```\n\nThe first version of the application is ready, which will evolve overtime, let's say. So now we can move over to `\"dockerizing\"` this application. I'll write each version of the app against the operation we do. \n\nTo build the docker image, I'll be using this command \n\n```bash\n$ docker build -t hello:v0.0.1 -f dockerfile . # \u003C-- replace the version for each build\n```\n\nOnce you have created an image, you can run it with this docker run command\n\n```bash\n$ docker run -p 8080:80 hello:v0.0.1 # \u003C-- you can now hit http://localhost:8080/\n```\n\n## v0.0.1 - Simple and Straightforward\n\nSo, first, let's write a very simple and straight forward dockerfile to create out image. You can see, we're just using the node's LTS tagged image to install our packages, building our project and running it. \n\n```docker\nFROM node:lts\n\nWORKDIR /app\n\nCOPY package* . \n\nRUN npm ci\n\nCOPY . .\n\nRUN npm run build\n\nENTRYPOINT node dist/src/main.js\n```\n\nI've also symlinked the `.gitignore` to `.dockerignore` as we don't need those in our context.\n\n```docker\n# compiled output\n/dist\n/node_modules\n\n# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\nlerna-debug.log*\n\n# OS\n.DS_Store\n\n# Tests\n/coverage\n/.nyc_output\n\n# IDEs and editors\n/.idea\n.project\n.classpath\n.c9/\n*.launch\n.settings/\n*.sublime-workspace\n\n# IDE - VSCode\n.vscode/*\n!.vscode/settings.json\n!.vscode/tasks.json\n!.vscode/launch.json\n!.vscode/extensions.json\n```\n\nSo, right now, we end-up with an image whose size is 1.23GB, which is bad news for just a hello sort of app. By the way, you can check the size of your images with in the `docker images` command. \n\n## v0.0.2 - Muliti Stage Builds\n\nHere, we'll build and package our application in separate environments. This will fix a few things for us -\n\n- the docker image will not container any `devDependency`\n- we can also choose to remove the test code or the source code entirely from the docker image\n\nFor the final image, we're using alpine tags. alpine is a lightweight linux distro and great for docker images.\n\n```docker\nFROM node:14.17.1 as buildEnv\n\nWORKDIR /app\n\nCOPY package* .\n\nRUN npm ci\n\nCOPY . .\n\nRUN npm run build\n\nFROM node:14.17.1-alpine # \u003C-- real small images\n\nWORKDIR /app\n\nCOPY --from=buildEnv /app/package* .\n\nRUN npm i --prod\n\nCOPY --from=buildEnv /app/dist dist\n\nENTRYPOINT node . # \u003C-- this works because of the 'main' property in package.json\n```\n\nThat was great! We have an image with a size of 130MB. That's great progress. But we can do better. How?\n\n## v0.0.3 - Install Node in an Alpine Image\n\nRather than using node's alpine tagged docker image, we can create our own from alpine images. So what will be trimming off? Well, node's alpine tags still contain things like `npm`, which we really don't need at runtime. (Maybe your app does, so this might not work for you.)\n\n```docker\nFROM node:lts as buildEnv\n\nWORKDIR /app\n\nCOPY package* .\n\nRUN npm ci\n\nCOPY . .\n\nRUN npm run build\n\nFROM node:lts-alpine as finalCodeEnv\n\nWORKDIR /app\n\nCOPY --from=buildEnv /app/package* .\n\nRUN npm i --prod\n\nCOPY --from=buildEnv /app/dist dist\n\nFROM alpine \n\nWORKDIR /app\n\nRUN apk add nodejs\n\nCOPY --from=finalCodeEnv /app .\n\nENTRYPOINT node .\n```\n\nWe've already reduced the image size from 1.23GB to 58.5MB - which is almost a twenty fold (`21.49X`) improvement, but can we go further? Since we've installed some packages with apk, maybe we can remove the cache to save some space. Let's add a new stage in our `dockerfile` to clear the apk cache. Let's give it a go!\n\n## v0.0.4 - Clear APK Cache\n\n```docker\nFROM node:lts as buildEnv\n\nWORKDIR /app\n\nCOPY package* .\n\nRUN npm ci\n\nCOPY . .\n\nRUN npm run build\n\nFROM node:lts-alpine as finalCodeEnv\n\nWORKDIR /app\n\nCOPY --from=buildEnv /app/package* .\n\nRUN npm i --prod\n\nCOPY --from=buildEnv /app/dist dist\n\nFROM alpine \n\nWORKDIR /app\n\nRUN apk add nodejs && rm -rf /var/cache/apk/* ## \u003C-- Clear APK Cache\n\nCOPY --from=finalCodeEnv /app .\n\nENTRYPOINT node .\n```\n\nIf you see the final image sizes, there's not much of a difference. After checking folder sizes inside the container, you can see our app is around 29MB. The next largest file is the `node` interpreter itself, around 30MB, so can't really do much about it. But, at the end of it all, it was a great exercise and now you can see how light-weight you can make nestjs, and nodejs images in general.\n\n```bash\n$ docker images --format \"{{.ID}}\\t{{.Size}}\\t{{.Repository}}\\t{{.Tag}}\" | sort -k 4 | grep hello\n\ne3f7f026264d\t1.23GB\thello\tv0.0.1\n167438686d8f\t130MB   hello\tv0.0.2\n7f83291130fd\t58.6MB\thello\tv0.0.3\nab3fc836943c\t56.5MB\thello\tv0.0.4\n```\n\nSo this was a guide as to how to downsize images when writing dockerfiles for your applications. Try this out with different sort of apps and languages. It's always fun to see how to creatively create optimized images. Enjoy! Happy coding!\n\n\\- [Saurav](https://twitter.com/mrsauravsahu)"],"uses":{"params":["blogId"]}}]}
